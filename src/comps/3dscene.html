<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ alpha: true });
    
    renderer.setSize(window.innerWidth, window.innerHeight);

    document.querySelector('.scene3d').appendChild(renderer.domElement);

    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    pmremGenerator.compileEquirectangularShader();
    new THREE.RGBELoader()
        .setDataType(THREE.UnsignedByteType)
        .setPath('{{domain_link}}/assets/models/')
        .load('unfinished_office_1k.hdr', function (texture) {
            const envMap = pmremGenerator.fromEquirectangular(texture).texture;
            scene.environment = envMap;
            scene.background = null;

            renderer.toneMapping = THREE.LinearToneMapping;
            renderer.toneMappingExposure = 1;

            texture.dispose();
            pmremGenerator.dispose();
        });

    const models = ['{{domain_link}}/assets/models/car-2.glb', '{{domain_link}}/assets/models/model1.glb', '{{domain_link}}/assets/models/model3.glb'];
    let currentModelIndex = 0;
    let currentModel;

    const loader = new THREE.GLTFLoader();
    function loadModel(index) {
        if (currentModel) {
            scaleDownModel(currentModel, () => {
                scene.remove(currentModel);
                loadNewModel(index);
            });
        } else {
            loadNewModel(index);
        }
    }

    function loadNewModel(index) {
        loader.load(models[index], function (gltf) {
            currentModel = gltf.scene;
            scene.add(currentModel);
            scaleUpModel(currentModel);
            getObjectNames(currentModel);
        }, undefined, function (error) {
            console.error(error);
        });
    }

    function getObjectNames(model) {
        model.traverse(child => {
            console.log(child.name);
        });

        model.traverse(child => {
            if (child.name === 'shadow') {
                child.visible = false;
                console.log('shadow hidden');  
            }
        });
    }

    function scaleDownModel(model, onComplete) {
        let scale = 1;
        const scaleDown = () => {
            scale -= 0.05;
            if (scale <= 0) {
                scale = 0;
                onComplete();
            } else {
                model.scale.set(scale, scale, scale);
                requestAnimationFrame(scaleDown);
            }
        };
        scaleDown();
    }

    function scaleUpModel(model) {
        let scale = 0;
        model.scale.set(scale, scale, scale);
        const scaleUp = () => {
            scale += 0.05;
            if (scale >= 1) {
                scale = 1;
            } else {
                model.scale.set(scale, scale, scale);
                requestAnimationFrame(scaleUp);
            }
        };
        scaleUp();
    }

    loadModel(currentModelIndex);

    camera.position.z = 5;
    camera.position.y = 3;

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.25;
    controls.enableZoom = true;
    controls.maxDistance = 5;
    controls.minDistance = 3;
    controls.maxPolarAngle = Math.PI / 2;
    controls.minPolarAngle = Math.PI / 4;

    function onWindowResize() {
        const container = document.querySelector('.scene3d');
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
        render();
    }

    let touchStartX = 0;
    let touchEndX = 0;

    let rotationAngle = 0;
    let rotationDirection = 1;

    let isAnimating = true;
    let lastTime = performance.now();

    function animate() {
        if (!isAnimating) return;
        const now = performance.now();
        const delta = now - lastTime;
        lastTime = now;

        requestAnimationFrame(animate);
        if (currentModel) {
            currentModel.rotation.y += 0.005 * delta / 16.67; // Adjust rotation speed based on elapsed time
        }
        controls.update();
        renderer.render(scene, camera);
    }
    animate();

    setInterval(() => {
        if (isAnimating) {
            currentModelIndex = (currentModelIndex + 1) % models.length;
            loadModel(currentModelIndex);
        }
    }, 5000);

    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            isAnimating = false;
        } else {
            isAnimating = true;
            lastTime = performance.now(); // Reset lastTime to avoid jump in animation
            animate();
        }
    });

    window.addEventListener('resize', onWindowResize, false);
</script>